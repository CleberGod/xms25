<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    :root {
      --bg1: #0b1028;
      --bg2: #030614;
      --bg3: #01020a;
      --accent: #c5ff87;
      --accent-2: #7ce7ff;
      --gold: #ffd166;
      --card: rgba(255, 255, 255, 0.06);
      --glass: rgba(255, 255, 255, 0.12);
      --text: #f8fbff;
      --muted: #a9b7d7;
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      background: radial-gradient(circle at 20% 15%, #1a2e4d 0%, #0b152b 25%, var(--bg1) 40%),
        radial-gradient(circle at 80% 0%, #16224b 0%, #0a142d 35%, var(--bg2) 55%),
        linear-gradient(180deg, var(--bg2) 0%, var(--bg3) 100%);
      overflow: hidden;
      font-family: "Space Grotesk", "Inter", "Segoe UI", system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
      color: var(--text);
    }

    .scene {
      position: relative;
      width: 100vw;
      height: 100vh;
      overflow: hidden;
    }

    canvas {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      display: block;
      transition: filter 1.6s ease, transform 1.2s ease;
      cursor: pointer;
    }

    .canvas-blur {
      filter: blur(14px) brightness(0.7);
      transform: scale(1.03);
    }

    .greeting {
      position: absolute;
      top: 6%;
      left: 50%;
      transform: translateX(-50%);
      text-align: center;
      pointer-events: none;
      transition: opacity 0.8s ease, transform 0.9s ease;
      z-index: 10;
      padding: 0.85rem 1.1rem;
      backdrop-filter: blur(4px);
      background: rgba(0, 0, 0, 0.25);
      border: 1px solid rgba(255, 255, 255, 0.18);
      border-radius: 14px;
      box-shadow: 0 10px 35px rgba(0, 0, 0, 0.35);
      width: auto;
    }

    .greeting.hidden {
      opacity: 0;
      transform: translateX(-50%) translateY(-10px);
    }

    .greeting .hint {
      display: block;
      font-size: clamp(1rem, 2vw, 1.2rem);
      letter-spacing: 0.18em;
      color: var(--muted);
      text-transform: uppercase;
      font-weight: 600;
      white-space: nowrap;
    }

    .final-message {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      text-align: center;
      opacity: 0;
      pointer-events: none;
      transition: opacity 1.6s ease;
      z-index: 20;
      width: min(520px, 92%);
      padding: 1.8rem 2rem;
      backdrop-filter: blur(10px);
      background: var(--card);
      border: 1px solid rgba(255, 255, 255, 0.12);
      border-radius: 20px;
      box-shadow: 0 15px 60px rgba(0, 0, 0, 0.35);
    }

    .final-message.visible {
      opacity: 1;
      pointer-events: auto;
    }

    .final-message h2 {
      font-size: clamp(2rem, 5vw, 3rem);
      color: var(--gold);
      text-shadow: 0 0 18px rgba(255, 215, 102, 0.5);
      margin-bottom: 0.9rem;
      line-height: 1.3;
      letter-spacing: 0.08em;
      text-transform: uppercase;
    }

    .final-message p {
      font-size: clamp(1.05rem, 2.2vw, 1.45rem);
      color: var(--text);
      letter-spacing: 0.08em;
      margin-bottom: 0.75rem;
    }

    .final-message small {
      display: inline-block;
      margin-top: 0.35rem;
      color: var(--muted);
      letter-spacing: 0.12em;
    }

    .badge {
      position: absolute;
      right: 4%;
      bottom: 5%;
      z-index: 25;
      padding: 0.75rem 1rem;
      background: var(--glass);
      border: 1px solid rgba(255, 255, 255, 0.08);
      backdrop-filter: blur(8px);
      border-radius: 18px;
      color: var(--muted);
      letter-spacing: 0.08em;
      font-size: 0.95rem;
      text-transform: uppercase;
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.35);
      animation: float 4s ease-in-out infinite;
    }

    @keyframes glowText {
      0%, 100% {
        text-shadow:
          0 0 4px rgba(255, 255, 255, 0.4),
          0 0 12px rgba(124, 231, 255, 0.55);
        transform: translateX(-50%) scale(1);
      }
      50% {
        text-shadow:
          0 0 14px rgba(197, 255, 135, 0.9),
          0 0 28px rgba(124, 231, 255, 1);
        transform: translateX(-50%) scale(1.04);
      }
    }

    @keyframes float {
      0%, 100% {
        transform: translateY(0);
      }
      50% {
        transform: translateY(-6px);
      }
    }
  </style>
</head>
<body>
  <div class="scene">
    <canvas id="treeCanvas"></canvas>
    
    <div class="greeting" id="initialText">
      <span class="hint">clique para iluminar</span>
    </div>

    <div class="final-message" id="finalText">
      <h2>Nós, do TI, Desejamos a todos um Feliz Natal</h2>
      <p>e um Próspero 2026!</p>
      <!--<small>clique novamente para voltar à árvore</small>-->
    </div>

    <div class="badge">estrelas ao toque</div>
  </div>

  <script>
    const canvas = document.getElementById("treeCanvas");
    const ctx = canvas.getContext("2d");

    let width = window.innerWidth;
    let height = window.innerHeight;

    let treeLights = [];
    let backgroundStars = [];
    let shootingStars = [];
    let risingStars = []; // Array para as estrelas da animação final
    let lastStarTime = 0;
    let messageTimeout = null;
    let isAnimationTriggered = false;

    function resize() {
      width = window.innerWidth;
      height = window.innerHeight;

      const ratio = window.devicePixelRatio || 1;
      canvas.width = width * ratio;
      canvas.height = height * ratio;
      ctx.setTransform(ratio, 0, 0, ratio, 0, 0);

      if (!isAnimationTriggered) {
        createTree();
      }
      createBackgroundStars();
    }

    window.addEventListener("resize", resize);
    resize();

    function startCelebration() {
      isAnimationTriggered = true;
      document.getElementById("initialText").classList.add("hidden");
      spawnRisingStars();

      messageTimeout = setTimeout(() => {
        canvas.classList.add("canvas-blur");
        document.getElementById("finalText").classList.add("visible");
      }, 1800);
    }

    function resetCelebration() {
      isAnimationTriggered = false;
      risingStars = [];
      shootingStars = [];
      treeLights = [];
      createTree();
      createBackgroundStars();
      document.getElementById("initialText").classList.remove("hidden");
      document.getElementById("finalText").classList.remove("visible");
      canvas.classList.remove("canvas-blur");
      if (messageTimeout) {
        clearTimeout(messageTimeout);
        messageTimeout = null;
      }
    }

    canvas.addEventListener("click", () => {
      if (!isAnimationTriggered) {
        startCelebration();
        return;
      }
      resetCelebration();
    });

    function createBackgroundStars() {
      backgroundStars = [];
      const count = Math.floor((width * height) / 9000);
      for (let i = 0; i < count; i++) {
        backgroundStars.push({
          x: Math.random() * width,
          y: Math.random() * height * 0.8,
          r: Math.random() * 1.3 + 0.3,
          alpha: Math.random(),
          speed: 0.002 + Math.random() * 0.003
        });
      }
    }

    function createTree() {
      treeLights = [];
      const centerX = width / 2;
      const baseY = height * 0.8;
      const treeHeight = height * 0.6;
      const treeWidth = treeHeight * 0.55;

      const layers = 40;
      const colors = ["#ffd27f", "#ff7a7a", "#8cf5ff", "#8fff9b", "#f9a9ff", "#c5ff87", "#7ce7ff"];

      for (let i = 0; i < layers; i++) {
        const t = i / layers;
        const layerY = baseY - t * treeHeight;
        const halfWidth = (1 - t) * treeWidth * 0.5;

        const dots = 12 + Math.floor((1 - t) * 18);
        for (let j = 0; j < dots; j++) {
          const offset = (Math.random() - 0.5) * 2 * halfWidth;
          const x = centerX + offset;
          const y = layerY + (Math.random() - 0.5) * (treeHeight / layers);

          treeLights.push({
            x,
            y,
            r: Math.random() * 2 + 1.2,
            baseAlpha: 0.35 + Math.random() * 0.45,
            phase: Math.random() * Math.PI * 2,
            speed: 0.02 + Math.random() * 0.04,
            color: colors[Math.floor(Math.random() * colors.length)]
          });
        }
      }

      const trunkWidth = treeWidth * 0.18;
      const trunkHeight = treeHeight * 0.12;
      const trunkX = centerX - trunkWidth / 2;
      const trunkY = baseY;

      treeLights.push({
        type: "trunk",
        x: trunkX,
        y: trunkY,
        w: trunkWidth,
        h: trunkHeight
      });
    }

    function spawnShootingStar() {
      const startX = -width * 0.1;
      const startY = height * (0.15 + Math.random() * 0.2);
      const speed = width * (0.004 + Math.random() * 0.002);
      const angle = (-15 - Math.random() * 10) * (Math.PI / 180);
      shootingStars.push({
        x: startX,
        y: startY,
        vx: Math.cos(angle) * speed,
        vy: Math.sin(angle) * speed,
        life: 0,
        maxLife: 2500 + Math.random() * 800
      });
    }

    function spawnRisingStars() {
      const count = 200;
      for (let i = 0; i < count; i++) {
        risingStars.push({
          x: Math.random() * width,
          y: height + Math.random() * 200,
          r: Math.random() * 3 + 1,
          vy: Math.random() * 8 + 4,
          vx: (Math.random() - 0.5) * 2,
          color: `hsl(${Math.random() * 60 + 30}, 100%, 70%)`,
          alpha: 1,
          decay: Math.random() * 0.005 + 0.002
        });
      }
    }

    function drawBackground() {
      const grd = ctx.createLinearGradient(0, 0, 0, height);
      grd.addColorStop(0, "#0a1030");
      grd.addColorStop(0.5, "#040817");
      grd.addColorStop(1, "#02040c");
      ctx.fillStyle = grd;
      ctx.fillRect(0, 0, width, height);
    }

    function drawBackgroundStars(delta) {
      for (const star of backgroundStars) {
        star.alpha += star.speed * delta;
        const a = 0.4 + Math.sin(star.alpha) * 0.4;
        ctx.save();
        ctx.globalAlpha = a;
        ctx.beginPath();
        ctx.arc(star.x, star.y, star.r, 0, Math.PI * 2);
        ctx.fillStyle = "#ffffff";
        ctx.shadowBlur = 6;
        ctx.shadowColor = "#7cc7ff";
        ctx.fill();
        ctx.restore();
      }
    }

    function drawTree(delta) {
      const centerX = width / 2;
      const baseY = height * 0.8;
      const treeHeight = height * 0.6;
      const treeWidth = treeHeight * 0.55;

      ctx.save();
      const grd = ctx.createRadialGradient(centerX, baseY, 10, centerX, baseY, treeWidth);
      grd.addColorStop(0, "rgba(25, 80, 100, 0.5)");
      grd.addColorStop(1, "rgba(2, 5, 8, 0)");
      ctx.fillStyle = grd;
      ctx.beginPath();
      ctx.ellipse(centerX, baseY + 10, treeWidth * 0.7, treeWidth * 0.25, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();

      for (const light of treeLights) {
        if (light.type === "trunk") {
          ctx.save();
          ctx.fillStyle = "#2b1b12";
          ctx.globalAlpha = 0.95;
          ctx.shadowBlur = 15;
          ctx.shadowColor = "#120b07";
          ctx.fillRect(light.x, light.y, light.w, light.h);
          ctx.restore();
        } else {
          light.phase += light.speed * delta * 0.06;
          const twinkle = light.baseAlpha + Math.sin(light.phase) * 0.2;

          ctx.save();
          ctx.globalAlpha = Math.max(0, Math.min(1, twinkle));
          ctx.beginPath();
          ctx.arc(light.x, light.y, light.r, 0, Math.PI * 2);
          ctx.fillStyle = light.color;
          ctx.shadowBlur = 18;
          ctx.shadowColor = light.color;
          ctx.fill();
          ctx.restore();
        }
      }

      const topX = centerX;
      const topY = baseY - treeHeight - 10;

      ctx.save();
      ctx.translate(topX, topY);
      ctx.rotate((Date.now() / 2000) % (Math.PI * 2));
      ctx.beginPath();
      const spikes = 5;
      const outerR = 16;
      const innerR = 7;
      for (let i = 0; i < spikes * 2; i++) {
        const r = (i % 2 === 0) ? outerR : innerR;
        const ang = (i * Math.PI) / spikes;
        ctx.lineTo(Math.cos(ang) * r, Math.sin(ang) * r);
      }
      ctx.closePath();
      const starGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, outerR);
      starGrad.addColorStop(0, "#ffffff");
      starGrad.addColorStop(0.4, "#ffe89b");
      starGrad.addColorStop(1, "rgba(255, 232, 155, 0)");
      ctx.fillStyle = starGrad;
      ctx.shadowBlur = 22;
      ctx.shadowColor = "#ffe89b";
      ctx.fill();
      ctx.restore();
    }

    function drawShootingStars(delta) {
      const now = performance.now();
      if (now - lastStarTime > 4000 + Math.random() * 3000) {
        spawnShootingStar();
        lastStarTime = now;
      }

      for (let i = shootingStars.length - 1; i >= 0; i--) {
        const s = shootingStars[i];
        s.life += delta;
        s.x += s.vx * (delta / 16.67);
        s.y += s.vy * (delta / 16.67);

        if (s.life > s.maxLife || s.x > width + 200 || s.y < -200) {
          shootingStars.splice(i, 1);
          continue;
        }

        ctx.save();
        ctx.lineWidth = 2;
        const tailLength = 80;
        const steps = 12;
        for (let t = 0; t < steps; t++) {
          const p = t / steps;
          const tx = s.x - s.vx * (p * tailLength / 100);
          const ty = s.y - s.vy * (p * tailLength / 100);
          ctx.globalAlpha = (1 - p) * 0.6;
          ctx.beginPath();
          ctx.moveTo(tx, ty);
          ctx.lineTo(tx - s.vx * 0.02, ty - s.vy * 0.02);
          ctx.strokeStyle = "#7cd8ff";
          ctx.shadowBlur = 10;
          ctx.shadowColor = "#53b7ff";
          ctx.stroke();
        }
        ctx.globalAlpha = 1;
        ctx.beginPath();
        ctx.arc(s.x, s.y, 4.5, 0, Math.PI * 2);
        ctx.fillStyle = "#bdf1ff";
        ctx.shadowBlur = 25;
        ctx.shadowColor = "#66d0ff";
        ctx.fill();
        ctx.restore();
      }
    }

    function drawRisingStars(delta) {
      for (let i = risingStars.length - 1; i >= 0; i--) {
        const p = risingStars[i];
        p.y -= p.vy * (delta / 16.67);
        p.x += p.vx * (delta / 16.67);
        p.alpha -= p.decay * (delta / 16.67);

        if (p.alpha <= 0 || p.y < -50) {
          risingStars.splice(i, 1);
          continue;
        }

        ctx.save();
        ctx.globalAlpha = p.alpha;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2);
        ctx.fillStyle = p.color;
        ctx.shadowBlur = 10;
        ctx.shadowColor = p.color;
        ctx.fill();
        ctx.restore();
      }
    }

    let lastTime = performance.now();

    function animate() {
      const now = performance.now();
      const delta = now - lastTime;
      lastTime = now;

      drawBackground();
      drawBackgroundStars(delta);
      drawTree(delta);
      drawShootingStars(delta);

      if (risingStars.length > 0) {
        drawRisingStars(delta);
      }

      requestAnimationFrame(animate);
    }

    animate();
  </script>
</body>
</html>
